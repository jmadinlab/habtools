---
title: "Complexity metrics for 3D meshes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Complexity metrics for 3D meshes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(habtools)
library(rgl)
options(rgl.printRglwidget = TRUE)
```

*habtools* includes a wide range of complexity metrics applicable to 3D meshes. 

Before, calculating any metrics, visualize your mesh and make sure that the z orientation is correct, as this may affect some of the calculations.
```{r}
plot3d(mcap)
```

Depending on how the mesh was generated (e.g. with the use of a laser scanner), the resolutions (distance between vertices inside the mesh) can vary a lot. This may affect calculations such as fractal dimension. Check the distribution of resolution of your object and if needed, remesh to make the resolution more uniform. 

```{r}
resvec <- Rvcg::vcgMeshres(mcap)[[2]] # vector of resolutions
hist(resvec)
summary(resvec)
```
In our example, the 'mcap' object has very variable distances between vertices. We can solve this issue by remeshing the object with the Rvcg function `vgcUniformRemesh()`. Here we set the resolution (voxelSize) to the minimum distance between points in the original mesh to ensure we don't loose details. This choice may be made on a case-to-case basis. Setting multisample to TRUE improves the accuracy of distance field computation, but slows down the calculation so this choice may be defined by computing power and the size of your object. The remeshed object now has a mean resolution of approximately the minimum of 'resvec'. While there will still be some variation in the obtained distances between vertices, the variation will be much smaller. An alternative option would be to remesh using an external 3D software such as blender. 

```{r}
mcap_uniform <- Rvcg::vcgUniformRemesh(mcap, silent = TRUE, multiSample = TRUE, voxelSize = min(resvec), mergeClost = TRUE)
plot3d(mcap_uniform, col = "grey")
Rvcg::vcgMeshres(mcap_uniform)[[1]]
summary(Rvcg::vcgMeshres(mcap_uniform)[[2]])
```


The three main metrics for DEMs also work for meshes. 
```{r}

# fractal dimension
fd(mcap_uniform, method = "cubes", diagnose = T)
fd(mcap_uniform, method = "area", plot = TRUE, diagnose = TRUE)

# rugosity
rg(mcap)

# height range 
hr(mcap)

```

For fractal dimension, two methods are available: "cubes" and "area". 
In the "cubes" method, fractal dimension is calculated as the slope of $log10(n) \sim log10(l)$, where n is the total number of cubes that contains any surface of the object and l is the size of the cubes (elements of lvec).
In the "area" method, the mesh is remeshed at varying resolutions (lvec) 
Further, you can calculate planar and total surface area of the object.
```{r}
planar(mcap)
surface_area(mcap)
```

              
There are a number of other metrics that tell you more about the shape of the object. See Zawada et al. (2019) for an example of an application of these metrics on corals.   
- **Convexity:** the ratio of the volume of the object and the volume of the convex hull around the object.     
- **Packing:** The ratio of the surface area of the object and the surface area of the convex hull around the object.    
- **Sphericity:** The ratio of the surface area of a sphere with the same volume as the object and the surface area of the object. 
- **Second moment of area (sma):** A measure of top-heaviness using area. Calculated by multiplying the surface area of each triangle in the mesh by its vertical distance from the origin.
- **Second moment of volume (smv):** A measure of top-heaviness using volume. For each triangle in the mesh, a tetrahedron between the triangle and the origin was calculated. The signed volume of each tetrahedron was multiplied by the vertical distance between the centroid of the tetrahedron and the centroid of the attachment plane.      
- **Mechanical shape factor (csf):**  Mechanical vulnerability of a structural element (Madin & Connolly, 2006).
```{r}
# convexity
convexity(mcap)

# packing
packing(mcap)

# sphericity
sphericity(mcap)

# second moment of area
sma(mcap)

# second moment of volume
smv(mcap)

# mechanical shape factor
csf(mcap, z_min = -3.65)$csf

```

You can also transform a 3D mesh to a DEM, and then apply DEM functions to the surface.

```{r}
dem <- mesh_to_dem(mcap, res = 0.015)
raster::plot(dem, asp=1)
rg(dem, L0 = 0.015, method = "area", parallel = FALSE) 

```

You can also transform a 3D mesh to a 2D drawing, and then apply 2D functions to the object

```{r}
pts <- mesh_to_2d(mcap)
plot(pts, asp=1)
fd_boxes(pts, plot = T, keep_data = F)
```

## References       
Zawada KJA, Dornelas M, Madin JS (2019) Quantifying coral morphology. Coral Reefs, 38:1281â€“1292.          
Madin JS & Connolly SR (2006) Ecological consequences of major hydrodynamic disturbances on coral reefs. Nature. 444:477-480.                


